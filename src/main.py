import csv
import subprocess
from os import path
from threading import Thread


class SpotifyDownload(object):

    def __init__(self, youtube_dl_path: str, csv_path: str, download_dest: str,
                 thread_count: int, additional_keywords="", audio_format="mp3"):

        self.youtube_dl_path = youtube_dl_path
        self.csv_path = csv_path
        self.download_dest = download_dest
        self.audio_format = audio_format
        self.additional_keywords = additional_keywords
        self.thread_count = thread_count

        if self.thread_count < 1:
            raise Exception("You need to use at least one thread")
        elif not path.exists(self.youtube_dl_path) or not path.exists(self.csv_path) or not path.exists(
                self.download_dest):
            raise Exception("The entered paths are invalid.")

    ### Takes a list and returns equally big chunks of it.
    def chunks(self, lst, n):
        for i in range(0, len(lst), n):
            yield lst[i:i + n]

    ### Starts the download process.
    def Start(self):
        print("Starting download...")
        self.distributeDownloadTasks(self.getDownloadCommands())
        print("Download finished.")

    ### Takes the csv file and extracts the name and Artist from every song, which is returned with a list of touples.
    def getSongArtistAndName(self):
        with open(self.csv_path, encoding='cp850', mode='r') as csv_file:
            csv_reader = csv.DictReader(csv_file)
            listSongInfo = []
            for row in csv_reader:
                listSongInfo.append((row["Track Name"], row["Artist Name(s)"]))
            return listSongInfo

    ### Generates Youtube-DL commands from the csv file.
    def getDownloadCommands(self):
        command_list = []
        song_list = self.getSongArtistAndName()
        for song in song_list:
            command_list.append(
                f"{self.youtube_dl_path} -x --audio-format {self.audio_format} -o"
                f" {self.download_dest}%(title)s.%(ext)s \"ytsearch1:{song[0]} {song[1]} {self.additional_keywords}\"")
        return command_list

    ### Takes a commandlist, generated by getDownloadCommands() and distributes them over the given amount of threads.
    def distributeDownloadTasks(self, commandList):
        command_chunks = self.chunks(commandList, int(round(len(commandList) / self.thread_count, 0)))
        thread_list = []

        for commands in command_chunks:
            thread_list.append(Thread(target=self.startThreadWithChunk, args=(commands,)))

        for thread in thread_list:
            thread.start()

        for thread in thread_list:
            thread.join()

    ### Calls a chunk of commands.
    def startThreadWithChunk(self, chunk):
        for command in chunk:
            subprocess.call(command)


if __name__ == '__main__':
    print("Welcome to this script!")
    SD = SpotifyDownload(
        input("Please enter the path to the 'youtube-dl.exe':"),
        input("Please enter the path to the downloaded csv file:"),
        input("Enter a path, where the music should be saved:"),
        int(input("Enter the amount of threads you want to use (number):")),
        input("Add additional keywords that should be added to the Youtube search:")
    )
    SD.Start()
